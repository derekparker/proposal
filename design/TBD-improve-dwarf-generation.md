# Proposal: Improve DWARF information in Go binaries.

Authors: Derek Parker (derek.parker@coreos.com) and Ryan Brown
(ribrdb@google.com)

Last updated: 2016/03/03

Discussion at [NO ISSUE FILED].

## Abstract

We propose moving DWARF debug information generation into the compiler, and
out of the linker. The linker will still be involved at the end of this
proposed change, however only to paste together the DWARF information that
has been generated during the compilation phase.

## Background

The current DWARF information generated by the Go linker is incomplete and
sometimes incorrect. In addition, the DWARF information is generated in the
linker as opposed to in the compiler, leading to the aforementioned issues due
to lack of necessary information in the linker, as well as increased compilation
times. Moving the DWARF generation into the compiler will reduce pressure on
the compiler to provide more information than necessary to the linker, and will
provide a solid foundation for these and future improvements to the debug 
information stored in Go binaries.

## Proposal

We propose a multi-step process:

1) Move all DWARF generation into the compiler. The linker will still need to be
   involved, but only to construct the final compilation unit. This will be a
   pure refactor, no improvements.
2) Improve DWARF output, full list of improvements follows.
3) Optimize DWARF generation / pasting (in linker).

At the end of the last step, we will have greatly improved the quality of DWARF
information provided in Go binaries. These changes also open the doors to future
improvements and optimizations.

### Move DWARF generation into the compiler

Currently the generation of the DWARF information is handled by the linker.
Moving this logic into the compiler (specifically the new SSA backend) will
provide several benefits:

- Access to scope information without need for additional instructions.
- Access to contants, currently the compiler does not emit constants in a way
  the linker can consume to produce DWARF information. (see
  https://github.com/golang/go/issues/14517).
- Speed improvements; DWARF can be generated in compiler during IR walk instead
  of compiler emiting required information for linker to construct all DWARF
  info.

#### Upfront issues:

**file/line number tables are rewritten by the linker to reflect the $GOROOT at
the time of link, and that's important for making binary distributions a bit
more relocatable (within the file system)**

Solution: The linker should be able to rewrite the file name tables in the line
tables easily enough to fix $GOROOT

**Go's fine-grained dead code elimination is not well aligned with DWARF's
compilation units, unless you make every declaration its own compilation unit.**

Solution: (quote from Austin Clements) "Russ and I chatted about this a bit
today and he suggested attaching DWARF snippets to each function and type and
the package as a whole and letting the linker paste these together to construct
the DWARF compilation units. Of course, the devil's in the details, but this
seems nicer than constructing the whole CU in the compiler and parsing it in the
linker to remove dead parts. Things like the abbrevs and opcode base are already
fixed, so it should be possible to paste these snippets together blindly with a
little help from relocations."

### Update to DWARF 3 or 4

Currently the linker emits DWARF 2 spec compliant debug info. There have been
many improvements since that spec that would allow for debuggers to work a lot
better. More specific information is provided below.

### Generate Function prologue end / epilogue start information

Note: Relies on upgrading DWARF output to at least version 3.

Include `prologue_end` and `epilogue_begin` booleans in .debug_lines line number
state machine registers.  Specifically, the line table header should include an
initial statement of:

`prologue_end: "false"` `epilogue_begin: "false"`

Additionally the line number program should include the following instructions:

`DW_LNS_set_prologue_end` and `DW_LNS_set_epilogue_begin`

to allow debuggers to skip the function prologue, and set breakpoints at the
function end (begin of epilogue).

### Include information on main subprogram

This depends on updating to emit DWARF 4 compatible code, but we could
potentially use this information to either encode `main.main` or (more helpfully
to debuggers) encode the very first entry into user (non-runtime) code, which
would be the first `init` function to be executed.

This would let debuggers provide a convienance to the user to put them in a
useful spot without user having to specify an initial breakpoint.

### Include scope information

Currently, the .debug_info section does not contain any scope information for
variables. This means that if a variable is shadowed there is no way to tell
which is active in the current scope. To remedy this, we must include a
`DW_TAG_lexical_block` tag, which should include either both `DW_AT_low_pc` and
`DW_AT_high_pc` or `DW_AT_ranges` to determine the length of the block.

Additionally, variables should include `DW_AT_start_scope`, possibly including a
range list.

### Include constants in debug info

Use `DW_TAG_constant` and `DW_AT_const_value`. See
https://github.com/golang/go/issues/14517 for further discussion.

### Use `lexical_block` to encode file scope

Since we're still planning on using a single compilation unit, we can (for the
time being) use `DW_TAG_lexical_block` to encode file scope information.

### Imrove debugging optimized programs

- Track registerized variables
- Encode information about inlined functions

### Fix incorrect variable naming

Wrong names (https://github.com/golang/go/issues/13949) The names in the debug
info are the linker names, not what appears in the source. Function names encode
the parent struct and package. Sometimes a variable “x” is renamed to “&x”

### Include 'rune' type in debug info

Allows debugger to properly format bytes.

### Wasted space

 - Use string table and string pointers instead of encoding all strings inline.
 - Remove unnecessary typedef for each type
 - Remove C++ template style encoding of channels and maps, instead rely on
   (non-spec) `DW_AT_go_key` and `DW_AT_go_elem`.

### Expose runtime information / api to debuggers

The debugger currently needs to know about the layout of the go runtime’s
internal data structures. It would be nice to remove this dependency so the
debugger can continue to work as the runtime changes or with multiple runtimes.

- String length: This can easily be represented in DWARF as shown below
- Slice capacity and length: This could be represented with a small dwarf
  extension shown below
- chan and map types
- Goroutines: it needs to find the list of all goroutines. For each go routine
  it needs an identifier, the running state, how to match running goroutines to
  their os thread (eg stack ranges), and how to unwind the stack for ones that
  are not running.
- Interfaces: Needs to understand iface, eface, \_type, uncommontype to find the
  runtime type of interfaces

As mentioned above, several of those items could by fixed by imroving the DWARF
information. 

## Rationale

The decision to move the DWARF generation into the compiler came after some
discussion, but should provide the best foundation for these, and future
improvements. The overall rationale being that the information needed to
provide full, correct DWARF information is readily available within the
compilation step. As opposed to forcing the compiler to provide even more
information to the linker, we simply move the generation of the DWARF debug
info into the compiler.

## Compatibility

Source level compatibility is not affected.

## Implementation

All proposed work is scheduled to be split between both Ryan and Derek. The
goal is to get all proposed changes merged withing the 1.7 cycle, and plan
further improvements for the 1.8 cycle.

## Open issues

- https://github.com/golang/go/issues/14517
- https://github.com/golang/go/issues/12899
- https://github.com/golang/go/issues/13949
