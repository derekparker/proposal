# Proposal: Improve DWARF information in Go binaries.

Authors: Derek Parker (derek.parker@coreos.com) and Ryan Brown
(ribrdb@google.com)

Last updated: 2016/02/28

Discussion at [NO ISSUE FILED].

## Abstract

The current DWARF information generated by the Go linker is incomplete and
sometimes incorrect. In addition, the DWARF information is generated in the
linker as opposed to in the compiler, leading to the aforementioned issues due
to lack of necessary information in the linker, as well as increased compilation
times.

## Background

[An introduction of the necessary background and the problem being solved by the
proposed change.]

## Proposal

*NOTE: STILL IN ROUGH DRAFT FORM*

### Move DWARF generation into the compiler

Currently the generation of the DWARF information is handled by the linker.
Moving this logic into the compiler (specifically the new SSA backend) will
provide several benefits:

- Access to scope information without need for additional instructions.
- Access to contants, currently the compiler does not emit constants in a way
  the linker can consume to produce DWARF information. (see
  https://github.com/golang/go/issues/14517).
- Speed improvements; DWARF can be generated in compiler during IR walk instead
  of compiler emiting required information for linker to construct all DWARF
  info.

#### Upfront issues:

**file/line number tables are rewritten by the linker to reflect the $GOROOT at
the time of link, and that's important for making binary distributions a bit
more relocatable (within the file system)**

Solution: The linker should be able to rewrite the file name tables in the line
tables easily enough to fix $GOROOT

**Go's fine-grained dead code elimination is not well aligned with DWARF's
compilation units, unless you make every declaration its own compilation unit.**

Solution: (quote from Austin Clements) "Russ and I chatted about this a bit
today and he suggested attaching DWARF snippets to each function and type and
the package as a whole and letting the linker paste these together to construct
the DWARF compilation units. Of course, the devil's in the details, but this
seems nicer than constructing the whole CU in the compiler and parsing it in the
linker to remove dead parts. Things like the abbrevs and opcode base are already
fixed, so it should be possible to paste these snippets together blindly with a
little help from relocations."

### Update to DWARF 3 or 4

Currently the linker emits DWARF 2 spec compliant debug info. There have been
many improvements since that spec that would allow for debuggers to work a lot
better. More specific information is provided below.

### Generate Function prologue end / epilogue start information

Note: Relies on upgrading DWARF output to at least version 3.

Include `prologue_end` and `epilogue_begin` booleans in .debug_lines line number
state machine registers.  Specifically, the line table header should include an
initial statement of:

`prologue_end: "false"` `epilogue_begin: "false"`

Additionally the line number program should include the following instructions:

`DW_LNS_set_prologue_end` and `DW_LNS_set_epilogue_begin`

to allow debuggers to skip the function prologue, and set breakpoints at the
function end (begin of epilogue).

### Include information on main subprogram

This depends on updating to emit DWARF 4 compatible code, but we could
potentially use this information to either encode `main.main` or (more helpfully
to debuggers) encode the very first entry into user (non-runtime) code, which
would be the first `init` function to be executed.

This would let debuggers provide a convienance to the user to put them in a
useful spot without user having to specify an initial breakpoint.

### Include scope information

Currently, the .debug_info section does not contain any scope information for
variables. This means that if a variable is shadowed there is no way to tell
which is active in the current scope. To remedy this, we must include a
`DW_TAG_lexical_block` tag, which should include either both `DW_AT_low_pc` and
`DW_AT_high_pc` or `DW_AT_ranges` to determine the length of the block.

Additionally, variables should include `DW_AT_start_scope`, possibly including a
range list.

### Include constants in debug info

Use `DW_TAG_constant` and `DW_AT_const_value`. See
https://github.com/golang/go/issues/14517 for further discussion.

### Multiple compilation units

Instead of a single compilation unit for all go code, we should have one
compilation unit per go source file. Packages should be represented using
`DW_TAG_namespace`, with `DW_AT_name` set to the name specified in the file, and
`DW_AT_linkage_name` set to the full package path.  Imports are represented
using `DW_TAG_imported_module`, with `DW_AT_name` set if the import is renamed.

### Imrove debugging optimized programs

- Track registerized variables
- Encode information about inlined functions

### Fix incorrect variable naming

Wrong names (https://github.com/golang/go/issues/13949) The names in the debug
info are the linker names, not what appears in the source. Function names encode
the parent struct and package. Sometimes a variable “x” is renamed to “&x”

### Include 'rune' type in debug info

Allows debugger to properly format bytes.

### Wasted space

 - Use string table and string pointers instead of encoding all strings inline.
 - Remove unnecessary typedef for each type
 - Remove C++ template style encoding of channels and maps, instead rely on
   (non-spec) `DW_AT_go_key` and `DW_AT_go_elem`.

### Expose runtime information / api to debuggers

The debugger currently needs to know about the layout of the go runtime’s
internal data structures. It would be nice to remove this dependency so the
debugger can continue to work as the runtime changes or with multiple runtimes.

- String length: This can easily be represented in DWARF as shown below
- Slice capacity and length: This could be represented with a small dwarf
  extension shown below
- chan and map types
- Goroutines: it needs to find the list of all goroutines. For each go routine
  it needs an identifier, the running state, how to match running goroutines to
  their os thread (eg stack ranges), and how to unwind the stack for ones that
  are not running.
- Interfaces: Needs to understand iface, eface, \_type, uncommontype to find the
  runtime type of interfaces

As mentioned above, several of those items could by fixed by imroving the DWARF
information. 

## Rationale

[A discussion of alternate approaches and the trade offs, advantages, and
disadvantages of the specified approach.]

## Compatibility

[A discussion of the change with regard to the [compatibility
guidelines](https://golang.org/doc/go1compat).]

## Implementation

[A description of the steps in the implementation, who will do them, and when.
This should include a discussion of how the work fits into [Go's release
cycle](https://golang.org/wiki/Go-Release-Cycle).]

## Open issues

- https://github.com/golang/go/issues/14517
- https://github.com/golang/go/issues/12899
- https://github.com/golang/go/issues/13949
